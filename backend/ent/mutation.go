// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/B5871803/app/ent/examinationroom"
	"github.com/B5871803/app/ent/nurse"
	"github.com/B5871803/app/ent/operative"
	"github.com/B5871803/app/ent/operativerecord"
	"github.com/B5871803/app/ent/tool"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeExaminationroom = "Examinationroom"
	TypeNurse           = "Nurse"
	TypeOperative       = "Operative"
	TypeOperativerecord = "Operativerecord"
	TypeTool            = "Tool"
)

// ExaminationroomMutation represents an operation that mutate the Examinationrooms
// nodes in the graph.
type ExaminationroomMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	examinationroomName        *string
	clearedFields              map[string]struct{}
	fromexaminationroom        map[int]struct{}
	removedfromexaminationroom map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Examinationroom, error)
}

var _ ent.Mutation = (*ExaminationroomMutation)(nil)

// examinationroomOption allows to manage the mutation configuration using functional options.
type examinationroomOption func(*ExaminationroomMutation)

// newExaminationroomMutation creates new mutation for $n.Name.
func newExaminationroomMutation(c config, op Op, opts ...examinationroomOption) *ExaminationroomMutation {
	m := &ExaminationroomMutation{
		config:        c,
		op:            op,
		typ:           TypeExaminationroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExaminationroomID sets the id field of the mutation.
func withExaminationroomID(id int) examinationroomOption {
	return func(m *ExaminationroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Examinationroom
		)
		m.oldValue = func(ctx context.Context) (*Examinationroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Examinationroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExaminationroom sets the old Examinationroom of the mutation.
func withExaminationroom(node *Examinationroom) examinationroomOption {
	return func(m *ExaminationroomMutation) {
		m.oldValue = func(context.Context) (*Examinationroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExaminationroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExaminationroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExaminationroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExaminationroomName sets the examinationroomName field.
func (m *ExaminationroomMutation) SetExaminationroomName(s string) {
	m.examinationroomName = &s
}

// ExaminationroomName returns the examinationroomName value in the mutation.
func (m *ExaminationroomMutation) ExaminationroomName() (r string, exists bool) {
	v := m.examinationroomName
	if v == nil {
		return
	}
	return *v, true
}

// OldExaminationroomName returns the old examinationroomName value of the Examinationroom.
// If the Examinationroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExaminationroomMutation) OldExaminationroomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExaminationroomName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExaminationroomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExaminationroomName: %w", err)
	}
	return oldValue.ExaminationroomName, nil
}

// ResetExaminationroomName reset all changes of the "examinationroomName" field.
func (m *ExaminationroomMutation) ResetExaminationroomName() {
	m.examinationroomName = nil
}

// AddFromexaminationroomIDs adds the fromexaminationroom edge to Operativerecord by ids.
func (m *ExaminationroomMutation) AddFromexaminationroomIDs(ids ...int) {
	if m.fromexaminationroom == nil {
		m.fromexaminationroom = make(map[int]struct{})
	}
	for i := range ids {
		m.fromexaminationroom[ids[i]] = struct{}{}
	}
}

// RemoveFromexaminationroomIDs removes the fromexaminationroom edge to Operativerecord by ids.
func (m *ExaminationroomMutation) RemoveFromexaminationroomIDs(ids ...int) {
	if m.removedfromexaminationroom == nil {
		m.removedfromexaminationroom = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromexaminationroom[ids[i]] = struct{}{}
	}
}

// RemovedFromexaminationroom returns the removed ids of fromexaminationroom.
func (m *ExaminationroomMutation) RemovedFromexaminationroomIDs() (ids []int) {
	for id := range m.removedfromexaminationroom {
		ids = append(ids, id)
	}
	return
}

// FromexaminationroomIDs returns the fromexaminationroom ids in the mutation.
func (m *ExaminationroomMutation) FromexaminationroomIDs() (ids []int) {
	for id := range m.fromexaminationroom {
		ids = append(ids, id)
	}
	return
}

// ResetFromexaminationroom reset all changes of the "fromexaminationroom" edge.
func (m *ExaminationroomMutation) ResetFromexaminationroom() {
	m.fromexaminationroom = nil
	m.removedfromexaminationroom = nil
}

// Op returns the operation name.
func (m *ExaminationroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Examinationroom).
func (m *ExaminationroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExaminationroomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.examinationroomName != nil {
		fields = append(fields, examinationroom.FieldExaminationroomName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExaminationroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case examinationroom.FieldExaminationroomName:
		return m.ExaminationroomName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExaminationroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case examinationroom.FieldExaminationroomName:
		return m.OldExaminationroomName(ctx)
	}
	return nil, fmt.Errorf("unknown Examinationroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExaminationroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case examinationroom.FieldExaminationroomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExaminationroomName(v)
		return nil
	}
	return fmt.Errorf("unknown Examinationroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExaminationroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExaminationroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExaminationroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Examinationroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExaminationroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExaminationroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExaminationroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Examinationroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExaminationroomMutation) ResetField(name string) error {
	switch name {
	case examinationroom.FieldExaminationroomName:
		m.ResetExaminationroomName()
		return nil
	}
	return fmt.Errorf("unknown Examinationroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExaminationroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fromexaminationroom != nil {
		edges = append(edges, examinationroom.EdgeFromexaminationroom)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExaminationroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case examinationroom.EdgeFromexaminationroom:
		ids := make([]ent.Value, 0, len(m.fromexaminationroom))
		for id := range m.fromexaminationroom {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExaminationroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfromexaminationroom != nil {
		edges = append(edges, examinationroom.EdgeFromexaminationroom)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExaminationroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case examinationroom.EdgeFromexaminationroom:
		ids := make([]ent.Value, 0, len(m.removedfromexaminationroom))
		for id := range m.removedfromexaminationroom {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExaminationroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExaminationroomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExaminationroomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Examinationroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExaminationroomMutation) ResetEdge(name string) error {
	switch name {
	case examinationroom.EdgeFromexaminationroom:
		m.ResetFromexaminationroom()
		return nil
	}
	return fmt.Errorf("unknown Examinationroom edge %s", name)
}

// NurseMutation represents an operation that mutate the Nurses
// nodes in the graph.
type NurseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	nurse_name     *string
	nurse_email    *string
	nurse_password *string
	nurse_tel      *string
	clearedFields  map[string]struct{}
	nurseop        map[int]struct{}
	removednurseop map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Nurse, error)
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows to manage the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for $n.Name.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the id field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNurseName sets the nurse_name field.
func (m *NurseMutation) SetNurseName(s string) {
	m.nurse_name = &s
}

// NurseName returns the nurse_name value in the mutation.
func (m *NurseMutation) NurseName() (r string, exists bool) {
	v := m.nurse_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseName returns the old nurse_name value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseName: %w", err)
	}
	return oldValue.NurseName, nil
}

// ResetNurseName reset all changes of the "nurse_name" field.
func (m *NurseMutation) ResetNurseName() {
	m.nurse_name = nil
}

// SetNurseEmail sets the nurse_email field.
func (m *NurseMutation) SetNurseEmail(s string) {
	m.nurse_email = &s
}

// NurseEmail returns the nurse_email value in the mutation.
func (m *NurseMutation) NurseEmail() (r string, exists bool) {
	v := m.nurse_email
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseEmail returns the old nurse_email value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseEmail: %w", err)
	}
	return oldValue.NurseEmail, nil
}

// ResetNurseEmail reset all changes of the "nurse_email" field.
func (m *NurseMutation) ResetNurseEmail() {
	m.nurse_email = nil
}

// SetNursePassword sets the nurse_password field.
func (m *NurseMutation) SetNursePassword(s string) {
	m.nurse_password = &s
}

// NursePassword returns the nurse_password value in the mutation.
func (m *NurseMutation) NursePassword() (r string, exists bool) {
	v := m.nurse_password
	if v == nil {
		return
	}
	return *v, true
}

// OldNursePassword returns the old nurse_password value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNursePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursePassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursePassword: %w", err)
	}
	return oldValue.NursePassword, nil
}

// ResetNursePassword reset all changes of the "nurse_password" field.
func (m *NurseMutation) ResetNursePassword() {
	m.nurse_password = nil
}

// SetNurseTel sets the nurse_tel field.
func (m *NurseMutation) SetNurseTel(s string) {
	m.nurse_tel = &s
}

// NurseTel returns the nurse_tel value in the mutation.
func (m *NurseMutation) NurseTel() (r string, exists bool) {
	v := m.nurse_tel
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseTel returns the old nurse_tel value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseTel: %w", err)
	}
	return oldValue.NurseTel, nil
}

// ResetNurseTel reset all changes of the "nurse_tel" field.
func (m *NurseMutation) ResetNurseTel() {
	m.nurse_tel = nil
}

// AddNurseopIDs adds the nurseop edge to Operativerecord by ids.
func (m *NurseMutation) AddNurseopIDs(ids ...int) {
	if m.nurseop == nil {
		m.nurseop = make(map[int]struct{})
	}
	for i := range ids {
		m.nurseop[ids[i]] = struct{}{}
	}
}

// RemoveNurseopIDs removes the nurseop edge to Operativerecord by ids.
func (m *NurseMutation) RemoveNurseopIDs(ids ...int) {
	if m.removednurseop == nil {
		m.removednurseop = make(map[int]struct{})
	}
	for i := range ids {
		m.removednurseop[ids[i]] = struct{}{}
	}
}

// RemovedNurseop returns the removed ids of nurseop.
func (m *NurseMutation) RemovedNurseopIDs() (ids []int) {
	for id := range m.removednurseop {
		ids = append(ids, id)
	}
	return
}

// NurseopIDs returns the nurseop ids in the mutation.
func (m *NurseMutation) NurseopIDs() (ids []int) {
	for id := range m.nurseop {
		ids = append(ids, id)
	}
	return
}

// ResetNurseop reset all changes of the "nurseop" edge.
func (m *NurseMutation) ResetNurseop() {
	m.nurseop = nil
	m.removednurseop = nil
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.nurse_name != nil {
		fields = append(fields, nurse.FieldNurseName)
	}
	if m.nurse_email != nil {
		fields = append(fields, nurse.FieldNurseEmail)
	}
	if m.nurse_password != nil {
		fields = append(fields, nurse.FieldNursePassword)
	}
	if m.nurse_tel != nil {
		fields = append(fields, nurse.FieldNurseTel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldNurseName:
		return m.NurseName()
	case nurse.FieldNurseEmail:
		return m.NurseEmail()
	case nurse.FieldNursePassword:
		return m.NursePassword()
	case nurse.FieldNurseTel:
		return m.NurseTel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldNurseName:
		return m.OldNurseName(ctx)
	case nurse.FieldNurseEmail:
		return m.OldNurseEmail(ctx)
	case nurse.FieldNursePassword:
		return m.OldNursePassword(ctx)
	case nurse.FieldNurseTel:
		return m.OldNurseTel(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldNurseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseName(v)
		return nil
	case nurse.FieldNurseEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseEmail(v)
		return nil
	case nurse.FieldNursePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursePassword(v)
		return nil
	case nurse.FieldNurseTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseTel(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldNurseName:
		m.ResetNurseName()
		return nil
	case nurse.FieldNurseEmail:
		m.ResetNurseEmail()
		return nil
	case nurse.FieldNursePassword:
		m.ResetNursePassword()
		return nil
	case nurse.FieldNurseTel:
		m.ResetNurseTel()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.nurseop != nil {
		edges = append(edges, nurse.EdgeNurseop)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeNurseop:
		ids := make([]ent.Value, 0, len(m.nurseop))
		for id := range m.nurseop {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removednurseop != nil {
		edges = append(edges, nurse.EdgeNurseop)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeNurseop:
		ids := make([]ent.Value, 0, len(m.removednurseop))
		for id := range m.removednurseop {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeNurseop:
		m.ResetNurseop()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// OperativeMutation represents an operation that mutate the Operatives
// nodes in the graph.
type OperativeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	operativeType        *string
	operativeName        *string
	clearedFields        map[string]struct{}
	fromoperative        map[int]struct{}
	removedfromoperative map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Operative, error)
}

var _ ent.Mutation = (*OperativeMutation)(nil)

// operativeOption allows to manage the mutation configuration using functional options.
type operativeOption func(*OperativeMutation)

// newOperativeMutation creates new mutation for $n.Name.
func newOperativeMutation(c config, op Op, opts ...operativeOption) *OperativeMutation {
	m := &OperativeMutation{
		config:        c,
		op:            op,
		typ:           TypeOperative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperativeID sets the id field of the mutation.
func withOperativeID(id int) operativeOption {
	return func(m *OperativeMutation) {
		var (
			err   error
			once  sync.Once
			value *Operative
		)
		m.oldValue = func(ctx context.Context) (*Operative, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperative sets the old Operative of the mutation.
func withOperative(node *Operative) operativeOption {
	return func(m *OperativeMutation) {
		m.oldValue = func(context.Context) (*Operative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OperativeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperativeType sets the operativeType field.
func (m *OperativeMutation) SetOperativeType(s string) {
	m.operativeType = &s
}

// OperativeType returns the operativeType value in the mutation.
func (m *OperativeMutation) OperativeType() (r string, exists bool) {
	v := m.operativeType
	if v == nil {
		return
	}
	return *v, true
}

// OldOperativeType returns the old operativeType value of the Operative.
// If the Operative object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperativeMutation) OldOperativeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperativeType is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperativeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperativeType: %w", err)
	}
	return oldValue.OperativeType, nil
}

// ResetOperativeType reset all changes of the "operativeType" field.
func (m *OperativeMutation) ResetOperativeType() {
	m.operativeType = nil
}

// SetOperativeName sets the operativeName field.
func (m *OperativeMutation) SetOperativeName(s string) {
	m.operativeName = &s
}

// OperativeName returns the operativeName value in the mutation.
func (m *OperativeMutation) OperativeName() (r string, exists bool) {
	v := m.operativeName
	if v == nil {
		return
	}
	return *v, true
}

// OldOperativeName returns the old operativeName value of the Operative.
// If the Operative object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperativeMutation) OldOperativeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperativeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperativeName: %w", err)
	}
	return oldValue.OperativeName, nil
}

// ResetOperativeName reset all changes of the "operativeName" field.
func (m *OperativeMutation) ResetOperativeName() {
	m.operativeName = nil
}

// AddFromoperativeIDs adds the fromoperative edge to Operativerecord by ids.
func (m *OperativeMutation) AddFromoperativeIDs(ids ...int) {
	if m.fromoperative == nil {
		m.fromoperative = make(map[int]struct{})
	}
	for i := range ids {
		m.fromoperative[ids[i]] = struct{}{}
	}
}

// RemoveFromoperativeIDs removes the fromoperative edge to Operativerecord by ids.
func (m *OperativeMutation) RemoveFromoperativeIDs(ids ...int) {
	if m.removedfromoperative == nil {
		m.removedfromoperative = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromoperative[ids[i]] = struct{}{}
	}
}

// RemovedFromoperative returns the removed ids of fromoperative.
func (m *OperativeMutation) RemovedFromoperativeIDs() (ids []int) {
	for id := range m.removedfromoperative {
		ids = append(ids, id)
	}
	return
}

// FromoperativeIDs returns the fromoperative ids in the mutation.
func (m *OperativeMutation) FromoperativeIDs() (ids []int) {
	for id := range m.fromoperative {
		ids = append(ids, id)
	}
	return
}

// ResetFromoperative reset all changes of the "fromoperative" edge.
func (m *OperativeMutation) ResetFromoperative() {
	m.fromoperative = nil
	m.removedfromoperative = nil
}

// Op returns the operation name.
func (m *OperativeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Operative).
func (m *OperativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OperativeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.operativeType != nil {
		fields = append(fields, operative.FieldOperativeType)
	}
	if m.operativeName != nil {
		fields = append(fields, operative.FieldOperativeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OperativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operative.FieldOperativeType:
		return m.OperativeType()
	case operative.FieldOperativeName:
		return m.OperativeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OperativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operative.FieldOperativeType:
		return m.OldOperativeType(ctx)
	case operative.FieldOperativeName:
		return m.OldOperativeName(ctx)
	}
	return nil, fmt.Errorf("unknown Operative field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operative.FieldOperativeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperativeType(v)
		return nil
	case operative.FieldOperativeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperativeName(v)
		return nil
	}
	return fmt.Errorf("unknown Operative field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OperativeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OperativeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OperativeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OperativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperativeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operative nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OperativeMutation) ResetField(name string) error {
	switch name {
	case operative.FieldOperativeType:
		m.ResetOperativeType()
		return nil
	case operative.FieldOperativeName:
		m.ResetOperativeName()
		return nil
	}
	return fmt.Errorf("unknown Operative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OperativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fromoperative != nil {
		edges = append(edges, operative.EdgeFromoperative)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OperativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operative.EdgeFromoperative:
		ids := make([]ent.Value, 0, len(m.fromoperative))
		for id := range m.fromoperative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OperativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfromoperative != nil {
		edges = append(edges, operative.EdgeFromoperative)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OperativeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operative.EdgeFromoperative:
		ids := make([]ent.Value, 0, len(m.removedfromoperative))
		for id := range m.removedfromoperative {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OperativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OperativeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OperativeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Operative unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OperativeMutation) ResetEdge(name string) error {
	switch name {
	case operative.EdgeFromoperative:
		m.ResetFromoperative()
		return nil
	}
	return fmt.Errorf("unknown Operative edge %s", name)
}

// OperativerecordMutation represents an operation that mutate the Operativerecords
// nodes in the graph.
type OperativerecordMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_OperativeTime         *time.Time
	clearedFields          map[string]struct{}
	examinationroom        *int
	clearedexaminationroom bool
	nurse                  *int
	clearednurse           bool
	operative              *int
	clearedoperative       bool
	tool                   *int
	clearedtool            bool
	done                   bool
	oldValue               func(context.Context) (*Operativerecord, error)
}

var _ ent.Mutation = (*OperativerecordMutation)(nil)

// operativerecordOption allows to manage the mutation configuration using functional options.
type operativerecordOption func(*OperativerecordMutation)

// newOperativerecordMutation creates new mutation for $n.Name.
func newOperativerecordMutation(c config, op Op, opts ...operativerecordOption) *OperativerecordMutation {
	m := &OperativerecordMutation{
		config:        c,
		op:            op,
		typ:           TypeOperativerecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperativerecordID sets the id field of the mutation.
func withOperativerecordID(id int) operativerecordOption {
	return func(m *OperativerecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Operativerecord
		)
		m.oldValue = func(ctx context.Context) (*Operativerecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operativerecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperativerecord sets the old Operativerecord of the mutation.
func withOperativerecord(node *Operativerecord) operativerecordOption {
	return func(m *OperativerecordMutation) {
		m.oldValue = func(context.Context) (*Operativerecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperativerecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperativerecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OperativerecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperativeTime sets the OperativeTime field.
func (m *OperativerecordMutation) SetOperativeTime(t time.Time) {
	m._OperativeTime = &t
}

// OperativeTime returns the OperativeTime value in the mutation.
func (m *OperativerecordMutation) OperativeTime() (r time.Time, exists bool) {
	v := m._OperativeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldOperativeTime returns the old OperativeTime value of the Operativerecord.
// If the Operativerecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperativerecordMutation) OldOperativeTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperativeTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperativeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperativeTime: %w", err)
	}
	return oldValue.OperativeTime, nil
}

// ResetOperativeTime reset all changes of the "OperativeTime" field.
func (m *OperativerecordMutation) ResetOperativeTime() {
	m._OperativeTime = nil
}

// SetExaminationroomID sets the examinationroom edge to Examinationroom by id.
func (m *OperativerecordMutation) SetExaminationroomID(id int) {
	m.examinationroom = &id
}

// ClearExaminationroom clears the examinationroom edge to Examinationroom.
func (m *OperativerecordMutation) ClearExaminationroom() {
	m.clearedexaminationroom = true
}

// ExaminationroomCleared returns if the edge examinationroom was cleared.
func (m *OperativerecordMutation) ExaminationroomCleared() bool {
	return m.clearedexaminationroom
}

// ExaminationroomID returns the examinationroom id in the mutation.
func (m *OperativerecordMutation) ExaminationroomID() (id int, exists bool) {
	if m.examinationroom != nil {
		return *m.examinationroom, true
	}
	return
}

// ExaminationroomIDs returns the examinationroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ExaminationroomID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) ExaminationroomIDs() (ids []int) {
	if id := m.examinationroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExaminationroom reset all changes of the "examinationroom" edge.
func (m *OperativerecordMutation) ResetExaminationroom() {
	m.examinationroom = nil
	m.clearedexaminationroom = false
}

// SetNurseID sets the nurse edge to Nurse by id.
func (m *OperativerecordMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the nurse edge to Nurse.
func (m *OperativerecordMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the edge nurse was cleared.
func (m *OperativerecordMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the nurse id in the mutation.
func (m *OperativerecordMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "nurse" edge.
func (m *OperativerecordMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// SetOperativeID sets the operative edge to Operative by id.
func (m *OperativerecordMutation) SetOperativeID(id int) {
	m.operative = &id
}

// ClearOperative clears the operative edge to Operative.
func (m *OperativerecordMutation) ClearOperative() {
	m.clearedoperative = true
}

// OperativeCleared returns if the edge operative was cleared.
func (m *OperativerecordMutation) OperativeCleared() bool {
	return m.clearedoperative
}

// OperativeID returns the operative id in the mutation.
func (m *OperativerecordMutation) OperativeID() (id int, exists bool) {
	if m.operative != nil {
		return *m.operative, true
	}
	return
}

// OperativeIDs returns the operative ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OperativeID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) OperativeIDs() (ids []int) {
	if id := m.operative; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperative reset all changes of the "operative" edge.
func (m *OperativerecordMutation) ResetOperative() {
	m.operative = nil
	m.clearedoperative = false
}

// SetToolID sets the tool edge to Tool by id.
func (m *OperativerecordMutation) SetToolID(id int) {
	m.tool = &id
}

// ClearTool clears the tool edge to Tool.
func (m *OperativerecordMutation) ClearTool() {
	m.clearedtool = true
}

// ToolCleared returns if the edge tool was cleared.
func (m *OperativerecordMutation) ToolCleared() bool {
	return m.clearedtool
}

// ToolID returns the tool id in the mutation.
func (m *OperativerecordMutation) ToolID() (id int, exists bool) {
	if m.tool != nil {
		return *m.tool, true
	}
	return
}

// ToolIDs returns the tool ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ToolID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) ToolIDs() (ids []int) {
	if id := m.tool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTool reset all changes of the "tool" edge.
func (m *OperativerecordMutation) ResetTool() {
	m.tool = nil
	m.clearedtool = false
}

// Op returns the operation name.
func (m *OperativerecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Operativerecord).
func (m *OperativerecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OperativerecordMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._OperativeTime != nil {
		fields = append(fields, operativerecord.FieldOperativeTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OperativerecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operativerecord.FieldOperativeTime:
		return m.OperativeTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OperativerecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operativerecord.FieldOperativeTime:
		return m.OldOperativeTime(ctx)
	}
	return nil, fmt.Errorf("unknown Operativerecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativerecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operativerecord.FieldOperativeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperativeTime(v)
		return nil
	}
	return fmt.Errorf("unknown Operativerecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OperativerecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OperativerecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativerecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operativerecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OperativerecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OperativerecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperativerecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operativerecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OperativerecordMutation) ResetField(name string) error {
	switch name {
	case operativerecord.FieldOperativeTime:
		m.ResetOperativeTime()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OperativerecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.examinationroom != nil {
		edges = append(edges, operativerecord.EdgeExaminationroom)
	}
	if m.nurse != nil {
		edges = append(edges, operativerecord.EdgeNurse)
	}
	if m.operative != nil {
		edges = append(edges, operativerecord.EdgeOperative)
	}
	if m.tool != nil {
		edges = append(edges, operativerecord.EdgeTool)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OperativerecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operativerecord.EdgeExaminationroom:
		if id := m.examinationroom; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeOperative:
		if id := m.operative; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeTool:
		if id := m.tool; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OperativerecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OperativerecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OperativerecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedexaminationroom {
		edges = append(edges, operativerecord.EdgeExaminationroom)
	}
	if m.clearednurse {
		edges = append(edges, operativerecord.EdgeNurse)
	}
	if m.clearedoperative {
		edges = append(edges, operativerecord.EdgeOperative)
	}
	if m.clearedtool {
		edges = append(edges, operativerecord.EdgeTool)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OperativerecordMutation) EdgeCleared(name string) bool {
	switch name {
	case operativerecord.EdgeExaminationroom:
		return m.clearedexaminationroom
	case operativerecord.EdgeNurse:
		return m.clearednurse
	case operativerecord.EdgeOperative:
		return m.clearedoperative
	case operativerecord.EdgeTool:
		return m.clearedtool
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OperativerecordMutation) ClearEdge(name string) error {
	switch name {
	case operativerecord.EdgeExaminationroom:
		m.ClearExaminationroom()
		return nil
	case operativerecord.EdgeNurse:
		m.ClearNurse()
		return nil
	case operativerecord.EdgeOperative:
		m.ClearOperative()
		return nil
	case operativerecord.EdgeTool:
		m.ClearTool()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OperativerecordMutation) ResetEdge(name string) error {
	switch name {
	case operativerecord.EdgeExaminationroom:
		m.ResetExaminationroom()
		return nil
	case operativerecord.EdgeNurse:
		m.ResetNurse()
		return nil
	case operativerecord.EdgeOperative:
		m.ResetOperative()
		return nil
	case operativerecord.EdgeTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord edge %s", name)
}

// ToolMutation represents an operation that mutate the Tools
// nodes in the graph.
type ToolMutation struct {
	config
	op              Op
	typ             string
	id              *int
	toolName        *string
	amount          *string
	clearedFields   map[string]struct{}
	fromtool        map[int]struct{}
	removedfromtool map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Tool, error)
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows to manage the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for $n.Name.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the id field of the mutation.
func withToolID(id int) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ToolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetToolName sets the toolName field.
func (m *ToolMutation) SetToolName(s string) {
	m.toolName = &s
}

// ToolName returns the toolName value in the mutation.
func (m *ToolMutation) ToolName() (r string, exists bool) {
	v := m.toolName
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old toolName value of the Tool.
// If the Tool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ToolMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToolName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName reset all changes of the "toolName" field.
func (m *ToolMutation) ResetToolName() {
	m.toolName = nil
}

// SetAmount sets the amount field.
func (m *ToolMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the amount value in the mutation.
func (m *ToolMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old amount value of the Tool.
// If the Tool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ToolMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount reset all changes of the "amount" field.
func (m *ToolMutation) ResetAmount() {
	m.amount = nil
}

// AddFromtoolIDs adds the fromtool edge to Operativerecord by ids.
func (m *ToolMutation) AddFromtoolIDs(ids ...int) {
	if m.fromtool == nil {
		m.fromtool = make(map[int]struct{})
	}
	for i := range ids {
		m.fromtool[ids[i]] = struct{}{}
	}
}

// RemoveFromtoolIDs removes the fromtool edge to Operativerecord by ids.
func (m *ToolMutation) RemoveFromtoolIDs(ids ...int) {
	if m.removedfromtool == nil {
		m.removedfromtool = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromtool[ids[i]] = struct{}{}
	}
}

// RemovedFromtool returns the removed ids of fromtool.
func (m *ToolMutation) RemovedFromtoolIDs() (ids []int) {
	for id := range m.removedfromtool {
		ids = append(ids, id)
	}
	return
}

// FromtoolIDs returns the fromtool ids in the mutation.
func (m *ToolMutation) FromtoolIDs() (ids []int) {
	for id := range m.fromtool {
		ids = append(ids, id)
	}
	return
}

// ResetFromtool reset all changes of the "fromtool" edge.
func (m *ToolMutation) ResetFromtool() {
	m.fromtool = nil
	m.removedfromtool = nil
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.toolName != nil {
		fields = append(fields, tool.FieldToolName)
	}
	if m.amount != nil {
		fields = append(fields, tool.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldToolName:
		return m.ToolName()
	case tool.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldToolName:
		return m.OldToolName(ctx)
	case tool.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	case tool.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ToolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ToolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldToolName:
		m.ResetToolName()
		return nil
	case tool.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fromtool != nil {
		edges = append(edges, tool.EdgeFromtool)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeFromtool:
		ids := make([]ent.Value, 0, len(m.fromtool))
		for id := range m.fromtool {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfromtool != nil {
		edges = append(edges, tool.EdgeFromtool)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeFromtool:
		ids := make([]ent.Value, 0, len(m.removedfromtool))
		for id := range m.removedfromtool {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	switch name {
	case tool.EdgeFromtool:
		m.ResetFromtool()
		return nil
	}
	return fmt.Errorf("unknown Tool edge %s", name)
}
